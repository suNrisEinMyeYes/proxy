Прокси контракт позволяет нам менять целевой смарт контракт, без ущерба данным и работе приложения.
1) Сама идея крутиться вокруг использования функции delegateCall, которая позволяет нам использовать память прокси, а не контракта имплементации. Это позволяет нам не заботиться о миграции данных. 
2) Имплементацию мы меняем заменяя значение в переменно прокси
3) важно понимать принцип работы евм(например то, что ссылка на следующий свободный слот лежит по адресу 0х40)
4) Также необходимо избегать коллизии. Например первая переменная в контракте имплементации в данном примере может затереться адресом контракта записанным в прокси. Коллизии мы избегаем при помощи bytes32(uint256(keccak256("eip1967.proxy.implementation"))-2); 
По сути мы просто кладем переменную в рандомный слот памяти. Это не лучшее решение данной проблемы, есть и другие, но как пример яя выбрал эту.
5) Весь код ассемблера я взял из мануала опензеппелина. 
6)Пояснения:

    Находим указатель на следующий свободный слот в памяти и кладем его в птр

    let ptr := mload(0x40)

    Нужно загрузить коллдату в свободный слот. Делаем это с помощью следующей строчки

    calldatacopy(ptr, 0, calldatasize())

    далее вызываем функцию delegatecall и сохраняем результат. 

    gas() - сообщает контракту сколько газа осталось = сколько можно потратить.
    impl - адрес вызываемого контракта
    ptr - адрес по которому сохранена коллдата
    calldatasize - описано в предыдущем пункте
    0, 0 - out, outvalue - мы перенаправляем все вызовы поэтому нам без разницы что там вернется, в этом и есть суть прокси 
    суть почему мы испульзуем такое решение в том, что мы не знаем что вернется, в этом и суть прокси, а такое решение позволяет обыграть строгую типизацию в солидити

    let result := delegatecall(gas(), impl, ptr, calldatasize(), 0, 0)

    Берем размер того что вернулось и кладем в тот же слот из которого отправляли(данные там нам больше не нужны)

    let size := returndatasize()

    returndatacopy(ptr, 0, size)

    Обрабатываем результат( при этом не важно какой, мы возвращаем одно и то же, но в случае неудачи просто ревертим)

    switch result
    case 0 {
        revert(ptr, size)
    }
    default {
        return(ptr, size)
    }
    }

    Решение по коллизии:
    Если бы я просто хранил переменную с адресом контракта примера, то первый слот в адресе прокируемого контракта затерся бы. По я генерирую адрес для переменной хэшируя строчку, это позволяет положить этот адрес в уникальное место которое вряд ли совпадет с переменными из проксируемого контракта

    загружает то, что находится по адресу слот в переменную ()
    assembly {
      a := sload(slot)
    }
    записываем в память переменную адрес по адресу слот
    assembly {
      sstore(slot, address_)
    }

    Причина почему мы помещаем вызов делегейт кола в фоллбэк функцию, потому что когда контракт не знает что эта за функция которую мы вызвали, он вызывает фоллбэк функцию, а в ней мы уже делигируем исполнение кода другому контракту